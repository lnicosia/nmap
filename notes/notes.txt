# Host netcat server
$ nc -l 127.0.0.1 -p 4242 -v -k

# Error
$ sudo ./ft_nmap scanme.org 4242
$ sudo nmap -p 4242 scanme.org
--------------------------------
Should be filtered

# Filter a port
$ sudo /sbin/iptables -A INPUT -p tcp --destination-port 4241 -j DROP

# SYN scan timeout
$ grep -nr "select" notes/strace.txt
select(5, [4], [4], [4], {tv_sec=1, tv_usec=533000})

# destination display before exiting
# leak g_data.destination in ft_strdup->parse_nmap_options

# match nmap port state when invalid packet

# Data structure

struct t_data {
	unsigned long long	opt;
	struct s_ip			*ips;
};

struct s_ip {
	struct sockaddr_in	*saddr; /* sockaddr_in of source */
	struct sockaddr_in	*daddr; /* sockaddr_in of dest */
	char				*destination; /* user input */
	int					status; /* [UP/DOWN] */
	struct s_port		*scans; /* list of ports to scan along with the type of scan */
	struct s_ip			*next; /* next ip */
};

struct s_port {
	int					scantype; /* Type of scan */
	int					status; /* Current status [READY/SCANNING/OPEN/CLOSED/FILTERED] */
	char				*service /* Found service */
	uint16_t			sport; /* Source port */
	uint16_t			dport; /* Destination port */
	struct s_port		*next; /* Next scan */
};

# Main thread reads scan list and redistributes tasks to workers
# When a worker is done, it sends the result to the main thread

www.google.com:
22  SYN     | 22  XMAS  | 22  UDP   | 23  SYN
 [SCANNING]    [OPEN]      [CLOSED]     [READY]

127.0.0.1:
22  SYN     | 22  XMAS  | 22  UDP   | 23  SYN
 [SCANNING]    [OPEN]      [CLOSED]     [READY]

./ft_nmap localhost -p 22 --scan=SYN,,FIN

ip.txt = 127.0.0.1
		 www.google.com

./ft_nmap localhost --file ip.txt -p 22 --scan=SYN,FIN

127.0.0.1 -> www.google.com

1 - 1024

min = 1
max = 1024

# nmap multiple ports (not range) handling ?
./ft_nmap localhsot -p 22,4242

# -p is not taken in consideration
sudo ./ft_nmap scanme.org --scan=SYN,FIN -p 4242
Same for --verbose=, i believe the arg parser is ignoring
the fact that optarg are given after the '='

localhost is UP
PORT   SCAN    STATE    TIME        SERVICE
22     SYN     OPEN     0000.007ms  ssh
|      FIN     OPEN     0000.003ms  ssh
1024   SYN     OPEN     0000.005ms  unknown
|      FIN     OPEN     0000.004ms  unknown
Scanned 1024 port(s), 0 error(s), 2 open, 0 filtered, 1022 closed

localhost is UP
PORT   SCAN    STATE    TIME        SERVICE
22
|      SYN     OPEN     0000.007ms  ssh
|      FIN     OPEN     0000.003ms  ssh
+------------------------------------------

1024
|      SYN     OPEN     0000.005ms  unknown
|      FIN     OPEN     0000.004ms  unknown
+------------------------------------------
Scanned 1024 port(s), 0 error(s), 2 open, 0 filtered, 1022 closed

# If number of ports > 26 do not print all status
sudo nmap -p 1-26,4242 localhost
PORT   STATE SERVICE
22/tcp open  ssh

sudo nmap -p 1-26 localhost
PORT   STATE  SERVICE
1/tcp  closed tcpmux
2/tcp  closed compressnet
3/tcp  closed compressnet
4/tcp  closed unknown
5/tcp  closed rje
6/tcp  closed unknown
[...]

sudo iptables -A OUTPUT -p tcp --source-port 4242 --tcp-flags RST RST -j DROP

non root scans with DGRAM sockets

vagrant@stretch:/vagrant$ nmap localhost -p 4242
4242/tcp filtered vrml-multi-use

vagrant@stretch:/vagrant$ sudo nmap localhost -p 4242
4242/tcp open  vrml-multi-use

# Flags d'opti (remove -g ?)

# Timeout in threads ?

# sudo ./ft_nmap localhost -p 1,20-28,2,3,4
Don't scan port 4

# sudo ./ft_nmap localhost -p 25-28,10
Scans last port only if > 9

# ERROR: sudo ./ft_nmap -p --2 localhost
infinite loop

# print date and hours at launch
"Starting Nmap 7.60 ( https://nmap.org ) at 2022-10-06 10:24 CEST"

# ERROR: [INFINITE LOOP] Change ft_random and increment ephemeral ports from min to max

#### Opti ####
Do not identify the services in each thread during runtime but before.
Going through the lists in every thread is slow. + the locking, and we do it two times:
when the thread is searching for a scan to do, and when the thread updates a scan it received.
So maybe use arrays or feed the threads with what scan they must do so they don't need to
search themselves?
Receiving in the threads is slow but it is necessary to receive soon enough after sending
otherwise we may lose the answers
#######

# Services
May use /usr/bin/../share/nmap/nmap-services instead for a better service recognition
